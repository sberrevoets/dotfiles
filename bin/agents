#!/usr/bin/env python3

import argparse
import os
import subprocess
import sys
import time
from pathlib import Path
from typing import Optional


def run(cmd: list[str], **kwargs) -> subprocess.CompletedProcess:
    return subprocess.run(cmd, capture_output=True, text=True, **kwargs)


def run_check(cmd: list[str], **kwargs) -> subprocess.CompletedProcess:
    return subprocess.run(cmd, capture_output=True, text=True, check=True, **kwargs)


def git(*args: str) -> subprocess.CompletedProcess:
    return run_check(["git", *args])


def repo_root() -> Path:
    result = git("rev-parse", "--show-toplevel")
    return Path(result.stdout.strip())


def agents_dir() -> Path:
    """Sibling directory: ../<repo>-agents/"""
    root = repo_root()
    return root.parent / f"{root.name}-agents"


def current_branch() -> str:
    return git("symbolic-ref", "--short", "HEAD").stdout.strip()


def is_agent_worktree() -> bool:
    """Check if cwd is inside an agent worktree."""
    try:
        root = repo_root()
        return root.parent.name.endswith("-agents")
    except subprocess.CalledProcessError:
        return False


def read_base_branch() -> str:
    base_file = repo_root() / ".agents-base"
    if not base_file.exists():
        print("Error: .agents-base not found. Are you in an agent worktree?")
        sys.exit(1)
    return base_file.read_text().strip()


def main_repo_root() -> Path:
    """Get the main repo root from an agent worktree."""
    root = repo_root()
    agents_parent = root.parent  # ../<repo>-agents
    repo_name = agents_parent.name.removesuffix("-agents")
    return agents_parent.parent / repo_name


def kill_tmux_window(name: str) -> None:
    """Kill any tmux window named '[agent] <name>' across all sessions."""
    if not _has_tmux():
        return
    result = run(["tmux", "list-windows", "-a", "-F", "#{session_name}:#{window_index} #{window_name}"])
    if result.returncode != 0:
        return
    target = f"[agent] {name}"
    for line in result.stdout.splitlines():
        parts = line.split(" ", 1)
        if len(parts) == 2 and parts[1] == target:
            run(["tmux", "kill-window", "-t", parts[0]])


def prune_stale() -> None:
    """Prune stale worktrees and orphaned agents/* branches."""
    git("worktree", "prune")

    result = run(["git", "branch", "--list", "agents/*"])
    if not result.stdout.strip():
        return

    worktree_result = git("worktree", "list", "--porcelain")
    worktree_paths = set()
    for line in worktree_result.stdout.splitlines():
        if line.startswith("worktree "):
            worktree_paths.add(line.split(" ", 1)[1])

    for line in result.stdout.splitlines():
        branch = line.strip()
        if not branch:
            continue
        # Check if any worktree uses this branch
        branch_in_use = False
        for wt_path in worktree_paths:
            wt_branch_result = run(
                ["git", "--work-tree", wt_path, "rev-parse", "--abbrev-ref", "HEAD"],
                cwd=wt_path,
            )
            if wt_branch_result.returncode == 0 and wt_branch_result.stdout.strip() == branch:
                branch_in_use = True
                break
        if not branch_in_use:
            run(["git", "branch", "-D", branch])


def cmd_new(name: Optional[str]) -> None:
    """Create a new agent worktree + tmux window."""
    if name is None:
        name = f"agent-{int(time.time()) % 100000}"

    branch = f"agents/{name}"
    base = current_branch()
    wt_dir = agents_dir() / name

    # Auto-prune before creating
    prune_stale()

    if wt_dir.exists():
        print(f"Error: worktree already exists at {wt_dir}")
        sys.exit(1)

    # Create worktree with new branch from HEAD
    wt_dir.parent.mkdir(parents=True, exist_ok=True)
    git("worktree", "add", "-b", branch, str(wt_dir), "HEAD")

    # Write base branch marker
    (wt_dir / ".agents-base").write_text(base + "\n")

    print(f"Created worktree: {wt_dir}")
    print(f"Branch: {branch} (from {base})")

    # tmux integration
    tmux_name = f"[agent] {name}"
    if os.environ.get("TMUX"):
        subprocess.run(
            ["tmux", "new-window", "-n", tmux_name, "-c", str(wt_dir)],
            check=True,
        )
    elif _has_tmux():
        session_name = f"agent-{name}"
        subprocess.run(
            ["tmux", "new-session", "-d", "-s", session_name, "-c", str(wt_dir)],
            check=True,
        )
        print(f"Created tmux session: {session_name}")
        print(f"Attach with: tmux attach -t {session_name}")
    else:
        print(f"cd {wt_dir}")


def _has_tmux() -> bool:
    return run(["which", "tmux"]).returncode == 0


def _has_fzf() -> bool:
    return run(["which", "fzf"]).returncode == 0


def _color(code: str, text: str) -> str:
    if not sys.stdout.isatty():
        return text
    return f"\033[{code}m{text}\033[0m"


def _short_path(path: Path) -> str:
    home = Path.home()
    try:
        return "~/" + str(path.relative_to(home))
    except ValueError:
        return str(path)


def _format_row(
    name: str, base: str, path: Path, ahead: int, behind: int,
    name_width: int, base_width: int,
) -> str:
    """Format a single agent row for display."""
    if behind > 0:
        bullet = _color("33", "●")  # yellow = stale
    else:
        bullet = _color("32", "●")  # green = up to date

    styled_name = _color("1;36", name.ljust(name_width))
    styled_base = _color("33", base.ljust(base_width))

    status_parts = []
    plain_parts = []
    if ahead > 0:
        status_parts.append(_color("32", f"↑{ahead}"))
        plain_parts.append(f"↑{ahead}")
    if behind > 0:
        status_parts.append(_color("31", f"↓{behind}"))
        plain_parts.append(f"↓{behind}")
    if not status_parts:
        status_parts.append(_color("2", "clean"))
        plain_parts.append("clean")
    status = " ".join(status_parts)
    visible_width = len(" ".join(plain_parts))
    padding = " " * max(0, 8 - visible_width)

    return f"  {bullet} {styled_name}  {styled_base}  {padding}{status}"


def _collect_agent_rows() -> list[tuple[str, str, Path, int, int]]:
    """Collect agent worktree data as (name, base, path, ahead, behind) rows."""
    result = git("worktree", "list", "--porcelain")
    entries: list[dict[str, str]] = []
    current: dict[str, str] = {}

    for line in result.stdout.splitlines():
        if line.startswith("worktree "):
            if current:
                entries.append(current)
            current = {"path": line.split(" ", 1)[1]}
        elif line.startswith("branch "):
            current["branch"] = line.split(" ", 1)[1].removeprefix("refs/heads/")
        elif line == "":
            if current:
                entries.append(current)
            current = {}
    if current:
        entries.append(current)

    agent_entries = [e for e in entries if e.get("branch", "").startswith("agents/")]

    rows = []
    for entry in agent_entries:
        path = Path(entry["path"])
        branch = entry["branch"]
        base_file = path / ".agents-base"
        base = base_file.read_text().strip() if base_file.exists() else "?"
        name = branch.removeprefix("agents/")

        behind, ahead = 0, 0
        if base != "?":
            counts = run(["git", "rev-list", "--left-right", "--count", f"{base}...{branch}"])
            if counts.returncode == 0:
                parts = counts.stdout.strip().split()
                if len(parts) == 2:
                    behind, ahead = int(parts[0]), int(parts[1])

        rows.append((name, base, path, ahead, behind))

    return rows


def cmd_list() -> None:
    """Show active agent worktrees."""
    rows = _collect_agent_rows()

    if not rows:
        print("No active agent worktrees.")
        return

    name_width = max(len(r[0]) for r in rows)
    base_width = max(len(r[1]) for r in rows)

    # Interactive fzf selection when available
    if sys.stdout.isatty() and _has_fzf():
        lines = []
        for name, base, path, ahead, behind in rows:
            display = _format_row(name, base, path, ahead, behind, name_width, base_width)
            lines.append(f"{name}\t{display}")
        result = subprocess.run(
            ["fzf", "--ansi", "--no-sort", "--reverse",
             "--height=~50%", "--delimiter=\t", "--with-nth=2.."],
            input="\n".join(lines),
            text=True,
            stdout=subprocess.PIPE,
        )
        if result.returncode == 0 and result.stdout.strip():
            agent_name = result.stdout.strip().split("\t", 1)[0]
            cmd_open(agent_name)
        return

    for name, base, path, ahead, behind in rows:
        print(_format_row(name, base, path, ahead, behind, name_width, base_width))


def cmd_merge() -> None:
    """Merge agent branch back to base branch."""
    if not is_agent_worktree():
        print("Error: not in an agent worktree.")
        sys.exit(1)

    agent_branch = current_branch()
    base = read_base_branch()
    main_root = main_repo_root()

    # Check for uncommitted changes
    status = git("status", "--porcelain")
    if status.stdout.strip():
        print("Error: uncommitted changes in agent worktree. Commit or stash first.")
        sys.exit(1)

    # Checkout base branch in main repo and merge
    run_check(["git", "-C", str(main_root), "checkout", base])
    result = run(
        ["git", "-C", str(main_root), "merge", "--ff", agent_branch],
    )

    if result.returncode == 0:
        print(f"Merged {agent_branch} into {base}.")
    else:
        # Try non-ff merge
        result2 = run(
            ["git", "-C", str(main_root), "merge", agent_branch],
        )
        if result2.returncode == 0:
            print(f"Merged {agent_branch} into {base} (merge commit).")
        else:
            print(f"Merge failed:\n{result2.stderr}")
            sys.exit(1)


def cmd_done() -> None:
    """Remove current agent worktree + branch, close tmux window."""
    if not is_agent_worktree():
        print("Error: not in an agent worktree.")
        sys.exit(1)

    agent_branch = current_branch()
    wt_path = repo_root()
    main_root = main_repo_root()

    # Move out of the worktree before removing it
    os.chdir(str(main_root))

    # Remove worktree
    run_check(["git", "-C", str(main_root), "worktree", "remove", "--force", str(wt_path)])

    # Delete branch
    run(["git", "-C", str(main_root), "branch", "-D", agent_branch])

    print(f"Removed worktree: {wt_path}")
    print(f"Deleted branch: {agent_branch}")

    # Close the agent's tmux window
    name = agent_branch.removeprefix("agents/")
    kill_tmux_window(name)


def find_agent_worktree(name: str) -> Optional[Path]:
    """Find the path of an agent worktree by name from git worktree list."""
    branch = f"agents/{name}"
    result = git("worktree", "list", "--porcelain")
    current: dict[str, str] = {}
    for line in result.stdout.splitlines():
        if line.startswith("worktree "):
            if current.get("branch") == f"refs/heads/{branch}":
                return Path(current["path"])
            current = {"path": line.split(" ", 1)[1]}
        elif line.startswith("branch "):
            current["branch"] = line.split(" ", 1)[1]
    if current.get("branch") == f"refs/heads/{branch}":
        return Path(current["path"])
    return None


def cmd_open(name: Optional[str]) -> None:
    """Open a tmux window for an existing agent worktree."""
    if name is None:
        if is_agent_worktree():
            name = current_branch().removeprefix("agents/")
        else:
            print("Error: specify an agent name, or run from inside an agent worktree.")
            sys.exit(1)

    wt_dir = find_agent_worktree(name)
    if wt_dir is None or not wt_dir.exists():
        print(f"Error: no agent worktree found for '{name}'.")
        print("Run 'agents list' to see active worktrees.")
        sys.exit(1)

    # Kill stale tmux window if one exists
    kill_tmux_window(name)

    tmux_name = f"[agent] {name}"
    if os.environ.get("TMUX"):
        subprocess.run(
            ["tmux", "new-window", "-n", tmux_name, "-c", str(wt_dir)],
            check=True,
        )
    elif _has_tmux():
        session_name = f"agent-{name}"
        subprocess.run(
            ["tmux", "new-session", "-d", "-s", session_name, "-c", str(wt_dir)],
            check=True,
        )
        print(f"Created tmux session: {session_name}")
        print(f"Attach with: tmux attach -t {session_name}")
    else:
        print(f"cd {wt_dir}")


def cmd_clean() -> None:
    """Remove all agent worktrees + their branches."""
    prune_stale()

    result = git("worktree", "list", "--porcelain")
    entries: list[dict[str, str]] = []
    current: dict[str, str] = {}

    for line in result.stdout.splitlines():
        if line.startswith("worktree "):
            if current:
                entries.append(current)
            current = {"path": line.split(" ", 1)[1]}
        elif line.startswith("branch "):
            current["branch"] = line.split(" ", 1)[1].removeprefix("refs/heads/")
        elif line == "":
            if current:
                entries.append(current)
            current = {}
    if current:
        entries.append(current)

    agent_entries = [e for e in entries if e.get("branch", "").startswith("agents/")]

    if not agent_entries:
        print("No agent worktrees to clean.")
        return

    for entry in agent_entries:
        path = entry["path"]
        branch = entry["branch"]

        # Skip worktrees with uncommitted changes
        status = run(["git", "-C", path, "status", "--porcelain"])
        if status.returncode == 0 and status.stdout.strip():
            print(f"  Skipping {branch} (has uncommitted changes)")
            continue

        # Close tmux window for this agent
        name = branch.removeprefix("agents/")
        kill_tmux_window(name)

        run(["git", "worktree", "remove", "--force", path])
        run(["git", "branch", "-D", branch])
        print(f"  Removed {branch}")

    print("Done.")


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Manage agent worktrees",
        usage="agents [command] [options]",
    )
    sub = parser.add_subparsers(dest="command")

    new_parser = sub.add_parser("new", help="Create a new agent worktree")
    new_parser.add_argument("name", nargs="?", help="Name for the worktree")

    sub.add_parser("list", help="List active agent worktrees")

    open_parser = sub.add_parser("open", help="Open tmux window for an existing agent worktree")
    open_parser.add_argument("name", nargs="?", help="Name of the agent worktree")

    sub.add_parser("merge", help="Merge agent branch back to base")
    sub.add_parser("rm", help="Remove current agent worktree")
    sub.add_parser("clean", help="Clean up stale worktrees")

    # Also allow bare `agents <name>` as shortcut for `agents new <name>`
    args, remaining = parser.parse_known_args()

    if args.command is None:
        if remaining:
            # Bare `agents <name>` is shortcut for `agents new <name>`
            cmd_new(remaining[0])
        else:
            cmd_list()
    elif args.command == "new":
        cmd_new(args.name)
    elif args.command == "list":
        cmd_list()
    elif args.command == "open":
        cmd_open(args.name)
    elif args.command == "merge":
        cmd_merge()
    elif args.command == "rm":
        cmd_done()
    elif args.command == "clean":
        cmd_clean()


if __name__ == "__main__":
    main()
